var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TRExMC","category":"page"},{"location":"#TRExMC.jl","page":"Home","title":"TRExMC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TRExMC.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TRExMC, Parameters, Models, Lattices, Hamiltonians, Observables, Algorithms, Simulations]","category":"page"},{"location":"#TRExMC.TRExMC","page":"Home","title":"TRExMC.TRExMC","text":"TRExMC: Thermodynamics via Replica-Exchange Monte Carlo\n\n\n\n\n\n","category":"module"},{"location":"#TRExMC.Models.Model","page":"Home","title":"TRExMC.Models.Model","text":"Model{L, H[, O]}\n\nThe main container used for simulations. The type parameters are given by\n\nR <: Random.AbstractRNG\nL <:AbstractLattice\nH <:AbstractHamiltonian\nO <:AbstractObservable\nIf no observable is provided, then the NullObservable is used.\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Hamiltonians.hamiltonian-Tuple{Model}","page":"Home","title":"TRExMC.Models.Hamiltonians.hamiltonian","text":"hamiltonian(::Model)\n\nConvenience function to access the <:AbstractHamiltonian of a Model.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Observables.measure!-Tuple{Model}","page":"Home","title":"TRExMC.Models.Observables.measure!","text":"measure!(m::Model)\n\nConvenience function to take measurements in a Model.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.iterate_DoFs-Tuple{AbstractModel}","page":"Home","title":"TRExMC.Models.iterate_DoFs","text":"iterate_DoFs(m::AbstractModel)\n\nWrapper to extract the Hamiltonian from the Model and  iterate.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.lattice-Tuple{Model}","page":"Home","title":"TRExMC.Models.lattice","text":"lattice(::Model)\n\nConvenience function to access the <:AbstractLattice of a Model.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.observables-Tuple{Model}","page":"Home","title":"TRExMC.Models.observables","text":"observables(::Model)\n\nConvenience function to access the <:AbstractObservables of a Model.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.rng-Tuple{Model}","page":"Home","title":"TRExMC.Models.rng","text":"rng(::Model)\n\nConvenience function to access the Random Number Generator a Model.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Lattices","page":"Home","title":"TRExMC.Models.Lattices","text":"module Lattices\n\nMain entry point for any simulated model to access an underlying geometrical structure. Currently comprised of the following subfiles:\n\n[AbstractLattices.jl]:\nInterface module that defines the `AbstractLattice as the supertype for all lattices\n[CubicLattices.jl]: \nDefines the AbstractCubicLattice subtype\nImplements the CubicLattice2D <: AbstractCubicLattice and the CubicLattice2DParams\n\n\n\n\n\n","category":"module"},{"location":"#TRExMC.Models.Lattices.AbstractLattice","page":"Home","title":"TRExMC.Models.Lattices.AbstractLattice","text":"abstract type AbstractLattice end\n\nThe supertype for all Types of lattices one can dream of.\n\nRequired Interface Methods\n\nOne must define the following methods for each new (non-abstract) AbstractLattice:\n\nBase.size\nconstruct_lattice!\nnum_sites\nsite_index\nnearest_neighbors\nparameters\n\nDefault Interface Methods\n\nThe following represent the default methods for AbstractLattices. One may still overload them for any peculiar subtype.\n\nDrWatson.savename\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Lattices.construct_lattice!-Tuple{TRExMC.Models.Lattices.AbstractLattice}","page":"Home","title":"TRExMC.Models.Lattices.construct_lattice!","text":"construct_lattice!(::AbstractLattice)\n\nBuild a lattice and its geometry. Meant to be used in a constructor.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Lattices.nearest_neighbors-Tuple{TRExMC.Models.Lattices.AbstractLattice, Any}","page":"Home","title":"TRExMC.Models.Lattices.nearest_neighbors","text":"nearest_neighbors(::AbstractLattice, site)\n\nReturn the set of nearest_neighbors for a given site in the AbstractLattice.\n\nExample\n\njulia> latt = Lattices.CubicLattice2D(4, 4);\n\njulia> Lattices.nearest_neighbors(latt, 1)\n4-element view(::Matrix{Int32}, 1, :) with eltype Int32:\n 13\n  4\n  2\n  5\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Lattices.num_sites-Tuple{TRExMC.Models.Lattices.AbstractLattice}","page":"Home","title":"TRExMC.Models.Lattices.num_sites","text":"num_sites(::AbstractLattice)\n\nReturn the number of sites that an AbstractLattice contains.\n\nExample\n\njulia> latt = Lattices.CubicLattice2D(4, 4);\n\njulia> Lattices.num_sites(latt)\n16\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Lattices.parameters-Tuple{TRExMC.Models.Lattices.AbstractLattice}","page":"Home","title":"TRExMC.Models.Lattices.parameters","text":"parameters(::AbstractLattice)\n\nReturn the parameters used to define the AbstractLattice.\n\nExample\n\njulia> latt = Lattices.CubicLattice2D(4, 4);\n\njulia> Lattices.parameters(latt)\nTRExMC.Models.Lattices.CubicLattice2DParams(4, 4)\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Lattices.site_index-Tuple{TRExMC.Models.Lattices.AbstractLattice, Any}","page":"Home","title":"TRExMC.Models.Lattices.site_index","text":"site_index(::AbstractLattice, indices::itr)\n\nCalculate the flattened index from an iterable set of indices in an AbstractLattice.\n\nExample\n\njulia> latt = Lattices.CubicLattice2D(4, 4);\n\njulia> Lattices.site_index(latt, (1, 2))\n5\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Hamiltonians.AbstractDoF","page":"Home","title":"TRExMC.Models.Hamiltonians.AbstractDoF","text":"abstract type AbstractDoF end\n\nParent type for all degrees of freedom used in the simulations.\n\nThe required interface for all DoF types is the following:\n\nDoF_location: Defines the in-memory identification for where the DoF is.\nDoF_value: Defines what the value of the DoF is (its current state).\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Hamiltonians.AbstractHamiltonian","page":"Home","title":"TRExMC.Models.Hamiltonians.AbstractHamiltonian","text":"abstract type AbstractHamiltonian end\n\nParent type for all Hamiltonians in the simulation.\n\nThe required interface that all Hamiltonians must satisfy are  specified by the following functions:\n\nDoF: the AbstractDoF stored at a given memory location\nenergy: total energy of the Hamiltonian\nDoF_energy: energy associated with a single AbstractDoF\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Hamiltonians.AbstractHamiltonianIterator","page":"Home","title":"TRExMC.Models.Hamiltonians.AbstractHamiltonianIterator","text":"abstract type AbstractHamiltonianIterator end\n\nIterface for iteration through a given Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Observables.AbstractObservables","page":"Home","title":"TRExMC.Models.Observables.AbstractObservables","text":"abstract type AbstractObservables end\n\nParent type for all observables.\n\nRequired Interface\n\nThe following methods must be implemented for all subtypes:\n\n* [`measure!`](@ref): how one should take measurements of a system for a given system configuration.\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Observables.NullObservable","page":"Home","title":"TRExMC.Models.Observables.NullObservable","text":"NullObservable <: AbstractObservables\n\nEmpty observable used for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"#TRExMC.Models.Observables._observables-Tuple{Any, AbstractDict}","page":"Home","title":"TRExMC.Models.Observables._observables","text":"_observables(name, symbol_funcs::AbstractDict)\n_observables(name, symbols, funcs)\n\nReturn an Expression used by the @observables macro.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Models.Observables.@observables-Tuple{Any, Any, Any}","page":"Home","title":"TRExMC.Models.Observables.@observables","text":"@observables name symbol_funcs::AbstractDict\n@observables name symbols funcs\n\nGenerate an AbstractObservables subtype with the given name whose fields will be denoted by the given symbols iterable. The measure! method will also be implemented with the supplied [funcs] iterable.\n\nAlternatively one can supply a Dictionary of symbol-function pairs as a single argument.\n\nnote: Note\nlength(symbols) == length(funcs) by construction.\n\n\n\n\n\n","category":"macro"},{"location":"#TRExMC.Algorithms.@algorithm-Tuple{Bool, Union{String, Symbol}, Vararg{Any}}","page":"Home","title":"TRExMC.Algorithms.@algorithm","text":"@algorithm\n\n\n\n\n\n","category":"macro"},{"location":"#TRExMC.Simulations.monte_carlo!-Tuple{Any, Any, Any}","page":"Home","title":"TRExMC.Simulations.monte_carlo!","text":"monte_carlo!(models, algorithm, mcparams)\n\nA single sweep of the Monte Carlo simulation. It's an  internal function that is supposed to be used by the  monte_carlo_run! function.\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Simulations.monte_carlo_run!-Tuple{Any, Any, Any}","page":"Home","title":"TRExMC.Simulations.monte_carlo_run!","text":"monte_carlo_run!(models, algorithm, mcparams; kwargs...)\n\nMain Monte Carlo function that performs a certain simulation algorithm on the systems defined by the given models. The parameters for the  simulation are contained with mcparams.\n\nCurrently, the available keyword arguments (kwargs) are:\n\nprocedure::AbstractMCProcedure = MonteCarloSimulation(): defines the type of simulation to be run \nverbose = false: whether to dump the progress for run during the simulation\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Simulations.run_and_record!-Tuple{Any, Any, Any}","page":"Home","title":"TRExMC.Simulations.run_and_record!","text":"run_and_record!(models, algorithm, mcparams; [kwargs...])\n\nMonte Carlo simulation for a set of models to be simulated in  parallel according to the specified algorithm with respect to the  given parameters, mcparams.\n\nnote: Note\nThis is a wrapper around monte_carlo_run! with  procedure = MonteCarloSimulation().\n\n\n\n\n\n","category":"method"},{"location":"#TRExMC.Simulations.thermalize!-Tuple{Any, Any, Any}","page":"Home","title":"TRExMC.Simulations.thermalize!","text":"thermalize(models, algorithm, mcparams; [kwargs...])\n\nThermalization process for a given set of models to be thermalized in parallel according to the specified algorithm with respect to the given parameters, mcparams.\n\nnote: Note\nThis is a wrapper around monte_carlo_run! with  procedure = Thermalization().\n\n\n\n\n\n","category":"method"}]
}
